#+DATE: 29 May 2011

Starting with Erlang...

Functional programming means different things to different people. My interest usually circles
around the axiom of immutability and its interesting consequences, particularly in the design of
concurrent systems. I've dabbled with functional languages in the past but haven't really built a
practical system in one yet. Recently, I was introduced to [[http://www.erlang.org/faq/introduction.html][Erlang]] which looked like a good choice
for solving practical problems. Last week, I was gifted [[http://pragprog.com/titles/jaerlang/programming-erlang][this book]] and that made it /the/ language
for my "functional" experiments.

This note is about how I set it up on my Windows box.

* Bootstrap
First, of course, I had to [[http://www.erlang.org/download.html][download]] and install the Erlang runtime. Second, I had to bring it home
by integrating it into emacs. That was done by putting the following few lines in my [[https://github.com/aldrin/ajd/blob/master/dotfiles/.emacs][.emacs]]:

#+BEGIN_SRC elisp
(when (and (getenv "ERLANG_ROOT") (getenv "ERLANG_EMACS"))
  (progn
    (setq load-path (cons (getenv "ERLANG_EMACS") load-path))
    (setq erlang-root-dir (getenv "ERLANG_ROOT"))
    (setq exec-path (cons (concat (getenv "ERLANG_ROOT") "/bin") exec-path))
    (require 'erlang-start)))
#+END_SRC

The =when= clause is required because my emacs start-up file is shared across boxes and I don't have
Erlang on all of them. On the box where I do have Erlang, I set two environment variables:
=ERLANG_ROOT= that points to the Erlang installation root and =ERLANG_EMACS= that points to the
=lib/tools-<ver>/emacs= sub-directory within the installation root.

With that done, we're ready to roll.

* First Program
I chose the [[http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes][Sieve of Eratosthenes]] as the first problem to solve. The algorithm is a simple way to
find primes less than a given number and requires enough Erlang primitives to exercise most of the
syntax I've been reading on the couch so far. Here's the [[https://github.com/aldrin/ajd/blob/master/code/misc/sieve.hrl][program]] in its entirety:

#+INCLUDE "../../code/misc/sieve.hrl" src erlang

The essence of the algorithm /is/ the program and the implementation is just 4 lines of code!
Typically, this is the point where functional programming aficionados jump over with joy and mumble
and blush about the elegance of it all. However, I'm not one of them, so I'll spare you all that. My
gravitation is more towards the concurrency and distributed-system aspects of Erlang, so I'll keep
the jumping over with joy for later, when I've had a chance to experience those aspects better.

For now, to execute this program, I return to emacs, hit =M-x erlang-shell= and do the following:

#+BEGIN_EXAMPLE
Eshell V5.8.3  (abort with ^G)
1> c(sieve).
{ok,sieve}
2> sieve:primes(100).
[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]
#+END_EXAMPLE

* Integrating with Powershell
Sieving primes is interesting but not exactly the kind of problem I need to solve daily. To maximize
the oppurtunites to learn it, it'd be nicer if I can use Erlang to solve more mundane problems, like
the ones we solve in shell scripts. The Erlang package does include a [[http://www.erlang.org/doc/man/escript.html][runtime variant]] for shell
scripting but that doesn't work all that well on Windows.

Here's a Powershell function that lets me use Erlang programs in the shell:

#+BEGIN_SRC powershell
# run erlang programs from the shell
function erlang
{
  param($script)
  if($env:ERLANG_ROOT)
  {
    invoke-expression "$env:ERLANG_ROOT\bin\erlc.exe $script.erl"
    if($lastexitcode -eq "0")
    {
      invoke-expression "$env:ERLANG_ROOT\bin\erl.exe -noshell -s $script main $args"
    }
  }
}
#+END_SRC

The function take an Erlang module name runs it using the runtime in the =-noshell= mode. It assumes
that module exports a =main/1= function that serves as the entry point. The program I wrote earlier
does not, so we'd need a driver module. [[https://github.com/aldrin/ajd/blob/master/code/misc/sieve.erl][Here]] is one:

#+INCLUDE "../../code/misc/sieve.erl" src erlang

Now those 4 lines can be run in Powershell instead of the Erlang shell:

#+BEGIN_EXAMPLE
C:\ajd\code\misc > erlang sieve 100
2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97
#+END_EXAMPLE

That then should open up Erlang for various interesting possibilities. [[http://wonderingminstrels.blogspot.com/2002/05/happiness-a-milne.html][And that, said John, is that]].
