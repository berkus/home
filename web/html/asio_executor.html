<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
lang="en" xml:lang="en">
<head>
<title>Thread-Pool Executor using Boost.ASIO</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="07 September 2011"/>
<meta name="author" content="aldrin j d'souza"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>



</head>
<body>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">Thread-Pool Executor using Boost.ASIO</h1>


<p>
Consider the problem of writing a thread pool executor: i.e. an abstraction that takes arbitrary
user defined tasks and executes them concurrently over a pool of threads. Here's a (slightly
overweight) <a href="http://download.oracle.com/javase/6/docs/api/java/util/concurrent/ThreadPoolExecutor.html">example</a> of the abstraction from <code>java.util.concurrent</code>. In this note, I describe another
(lean) implementation using a few bits from the treasure trove of <a href="http://www.boost.org/doc/libs/1_47_0/doc/html/boost_asio.html">Boost.ASIO</a>.
</p>
<p>
<a href="https://github.com/aldrin/ajd/blob/master/code/ajd/explore/test/src/executor_test.cc">Here's</a> what I expect from the executor (syntactically):
</p>



<pre class="src src-c++"><span style="color: #87ffd7;">#include</span> <span style="color: #ffaf87;">"executor.h"</span>
<span style="color: #87ffd7;">#include</span> <span style="color: #ffaf87;">&lt;gtest/gtest.h&gt;</span>

<span style="color: #cdcd00; font-size: 105%;">void</span> <span style="color: #0087ff; font-size: 105%; font-weight: bold;">work</span>() {}
<span style="color: #cdcd00; font-size: 105%;">void</span> <span style="color: #0087ff; font-size: 105%; font-weight: bold;">other_work</span>(<span style="color: #ffafaf; font-size: 105%;">const</span> <span style="color: #cdcd00; font-size: 105%;">char</span> *<span style="color: #ffd700;">c</span>) {}
<span style="color: #ffafaf; font-size: 105%;">struct</span> <span style="color: #cdcd00; font-size: 105%;">functor_work</span> { <span style="color: #cdcd00; font-size: 105%;">void</span> <span style="color: #ffafaf; font-size: 105%;">operator</span><span style="color: #0087ff; font-size: 105%; font-weight: bold;">()</span>() {} };
<span style="color: #ffafaf; font-size: 105%;">auto</span> <span style="color: #cdcd00; font-size: 105%;">lambda</span> = [] {};

<span style="color: #0087ff; font-size: 105%; font-weight: bold;">TEST</span>(Executor, UsageSyntax)
{
  <span style="color: #87ffd7;">ajd</span>::<span style="color: #cdcd00; font-size: 105%;">executor</span> <span style="color: #ffd700;">e</span>(2);
  e.submit(work);
  e.submit(<span style="color: #87ffd7;">boost</span>::bind(other_work, <span style="color: #ffaf87;">"input"</span>));
  e.submit(functor_work());
  e.submit(lambda);
}
</pre>




<p>
I expect to create an executor with the specified number of threads in its pool and to have it ready
to jobs that I submit during the lifetime of the instance. The destructor must wait till the last
submitted job is completed and then clean up everything. As far as the tasks go, anything that is
invokable must be acceptable.
</p>
<p>
With those requirements in mind, <a href="https://github.com/aldrin/ajd/blob/master/code/ajd/explore/main/include/executor.h">here</a>'s an complete implementation:
</p>



<pre class="src src-c++"><span style="color: #87ffd7;">#if</span><span style="color: #87ffd7;">n</span><span style="color: #87ffd7;">def</span> AJD_EXECUTOR_H_
<span style="color: #87ffd7;">#define</span> <span style="color: #ffd700;">AJD_EXECUTOR_H_</span>

<span style="color: #87ffd7;">#include</span> <span style="color: #ffaf87;">&lt;boost/asio.hpp&gt;</span>
<span style="color: #87ffd7;">#include</span> <span style="color: #ffaf87;">&lt;boost/bind.hpp&gt;</span>
<span style="color: #87ffd7;">#include</span> <span style="color: #ffaf87;">&lt;boost/thread.hpp&gt;</span>

<span style="color: #ffafaf; font-size: 105%;">namespace</span> <span style="color: #87ffd7;">ajd</span>
{
  <span style="color: #ffafaf; font-size: 105%;">using</span> <span style="color: #87ffd7;">boost</span>::<span style="color: #cdcd00; font-size: 105%;">bind</span>;
  <span style="color: #ffafaf; font-size: 105%;">using</span> <span style="color: #87ffd7;">boost</span>::<span style="color: #cdcd00; font-size: 105%;">thread</span>;
  <span style="color: #ffafaf; font-size: 105%;">using</span> <span style="color: #87ffd7;">boost</span>::<span style="color: #cdcd00; font-size: 105%;">thread_group</span>;
  <span style="color: #ffafaf; font-size: 105%;">using</span> <span style="color: #87ffd7;">boost</span>::<span style="color: #87ffd7;">asio</span>::<span style="color: #cdcd00; font-size: 105%;">io_service</span>;

  <span style="color: #ffafaf; font-size: 105%;">class</span> <span style="color: #cdcd00; font-size: 105%;">executor</span>
  {
  <span style="color: #ffafaf; font-size: 105%;">public</span>:

    <span style="color: #0087ff; font-size: 105%; font-weight: bold;">executor</span>(<span style="color: #cdcd00; font-size: 105%;">size_t</span> <span style="color: #ffd700;">n</span>): service_(n), work_(service_)
    {
      <span style="color: #ffafaf; font-size: 105%;">for</span> (<span style="color: #cdcd00; font-size: 105%;">size_t</span> <span style="color: #ffd700;">i</span> = 0; i &lt; n; i++)
      { pool_.create_thread(bind(&amp;<span style="color: #87ffd7;">io_service</span>::run, &amp;service_)); }
    }

    ~<span style="color: #0087ff; font-size: 105%; font-weight: bold;">executor</span>()
    {
      service_.stop();
      pool_.join_all();
    }

    <span style="color: #ffafaf; font-size: 105%;">template</span>&lt;<span style="color: #ffafaf; font-size: 105%;">typename</span> <span style="color: #cdcd00; font-size: 105%;">F</span>&gt; <span style="color: #cdcd00; font-size: 105%;">void</span> <span style="color: #0087ff; font-size: 105%; font-weight: bold;">submit</span>(<span style="color: #cdcd00; font-size: 105%;">F</span> <span style="color: #ffd700;">task</span>)
    {
      service_.post(task);
    }

  <span style="color: #ffafaf; font-size: 105%;">protected</span>:
    <span style="color: #cdcd00; font-size: 105%;">thread_group</span> <span style="color: #ffd700;">pool_</span>;
    <span style="color: #cdcd00; font-size: 105%;">io_service</span> <span style="color: #ffd700;">service_</span>;
    <span style="color: #87ffd7;">io_service</span>::<span style="color: #cdcd00; font-size: 105%;">work</span> <span style="color: #ffd700;">work_</span>;
  };
}

<span style="color: #87ffd7;">#endif</span> <span style="color: #87ff87; font-style: italic;">// </span><span style="color: #87ff87; font-style: italic;">AJD_EXECUTOR_H_</span>
</pre>




<p>
As someone who has written shabbily stitched executors in the past, I can't help but marvel at the
economy of this implementation. No dispatch queues, no mutexes to guard share state, no condition
variables to signal job arrivals, no shutdown flags, no nothing. Just the neat, power-packed
<code>asio::io_service</code> facade and we're done. Of course, there's still quite a bit left before we use
this in a complete application, but how cool is that for a start?
</p></div>

<div id="postamble">
<p class="date">Date: 07 September 2011</p>
<p class="author">Author: aldrin j d'souza</p>
<p class="creator">Org version 7.7 with Emacs version 23</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
