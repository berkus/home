<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
lang="en" xml:lang="en">
<head>
<title>Starting with Erlang&hellip;</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="29 May 2011"/>
<meta name="author" content="aldrin j d'souza"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>



</head>
<body>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">Starting with Erlang&hellip;</h1>


<p>
Functional programming means different things to different people. My interest usually circles
around the axiom of immutability and its interesting consequences, particularly in the design of
concurrent systems. I've dabbled with functional languages in the past but haven't really built a
practical system in one yet. Recently, I was introduced to <a href="http://www.erlang.org/faq/introduction.html">Erlang</a> which looked like a good choice
for solving practical problems. Last week, I was gifted <a href="http://pragprog.com/titles/jaerlang/programming-erlang">this book</a> and that made it <i>the</i> language
for my "functional" experiments.
</p>
<p>
This note is about how I set it up on my Windows box.
</p>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">Bootstrap </h2>
<div class="outline-text-2" id="text-1">

<p>First, of course, I had to <a href="http://www.erlang.org/download.html">download</a> and install the Erlang runtime. Second, I had to bring it home
by integrating it into emacs. That was done by putting the following few lines in my <a href="https://github.com/aldrin/ajd/blob/master/dotfiles/.emacs">.emacs</a>:
</p>



<pre class="src src-elisp">(<span style="color: #ffafaf; font-size: 105%;">when</span> (and (getenv <span style="color: #ffaf87;">"ERLANG_ROOT"</span>) (getenv <span style="color: #ffaf87;">"ERLANG_EMACS"</span>))
  (<span style="color: #ffafaf; font-size: 105%;">progn</span>
    (setq load-path (cons (getenv <span style="color: #ffaf87;">"ERLANG_EMACS"</span>) load-path))
    (setq erlang-root-dir (getenv <span style="color: #ffaf87;">"ERLANG_ROOT"</span>))
    (setq exec-path (cons (concat (getenv <span style="color: #ffaf87;">"ERLANG_ROOT"</span>) <span style="color: #ffaf87;">"/bin"</span>) exec-path))
    (<span style="color: #ffafaf; font-size: 105%;">require</span> '<span style="color: #87ffd7;">erlang-start</span>)))
</pre>




<p>
The <code>when</code> clause is required because my emacs start-up file is shared across boxes and I don't have
Erlang on all of them. On the box where I do have Erlang, I set two environment variables:
<code>ERLANG_ROOT</code> that points to the Erlang installation root and <code>ERLANG_EMACS</code> that points to the
<code>lib/tools-&lt;ver&gt;/emacs</code> sub-directory within the installation root.
</p>
<p>
With that done, we're ready to roll.
</p>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">First Program </h2>
<div class="outline-text-2" id="text-2">

<p>I chose the <a href="http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">Sieve of Eratosthenes</a> as the first problem to solve. The algorithm is a simple way to
find primes less than a given number and requires enough Erlang primitives to exercise most of the
syntax I've been reading on the couch so far. Here's the <a href="https://github.com/aldrin/ajd/blob/master/code/misc/sieve.hrl">program</a> in its entirety:
</p>



<pre class="src src-erlang">% Sieve of Eratosthenes
primes(N) -&gt; primes(lists:seq(3, N, 2), round(math:sqrt(N) + 0.5), [2]).
primes([First|Rest], Max, Result) when First &lt; Max -&gt; primes([X || X &lt;- Rest, (X rem First) =/= 0], Max, [First|Result]);
primes([First|Rest], Max, Result) -&gt; primes(Rest, Max, [First|Result]);
primes([], _Max, Result) -&gt; lists:reverse(Result).
</pre>




<p>
The essence of the algorithm <i>is</i> the program and the implementation is just 4 lines of code!
Typically, this is the point where functional programming aficionados jump over with joy and mumble
and blush about the elegance of it all. However, I'm not one of them, so I'll spare you all that. My
gravitation is more towards the concurrency and distributed-system aspects of Erlang, so I'll keep
the jumping over with joy for later, when I've had a chance to experience those aspects better.
</p>
<p>
For now, to execute this program, I return to emacs, hit <code>M-x erlang-shell</code> and do the following:
</p>



<pre class="example">Eshell V5.8.3  (abort with ^G)
1&gt; c(sieve).
{ok,sieve}
2&gt; sieve:primes(100).
[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]
</pre>



</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3">Integrating with Powershell </h2>
<div class="outline-text-2" id="text-3">

<p>Sieving primes is interesting but not exactly the kind of problem I need to solve daily. To maximize
the oppurtunites to learn it, it'd be nicer if I can use Erlang to solve more mundane problems, like
the ones we solve in shell scripts. The Erlang package does include a <a href="http://www.erlang.org/doc/man/escript.html">runtime variant</a> for shell
scripting but that doesn't work all that well on Windows.
</p>
<p>
Here's a Powershell function that lets me use Erlang programs in the shell:
</p>



<pre class="src src-powershell"><span style="color: #87ff87; font-style: italic;"># run erlang programs from the shell</span>
<span style="color: #ffafaf; font-size: 105%;">function</span> erlang
{
  param(<span style="color: #ffd700;">$script</span>)
  <span style="color: #ffafaf; font-size: 105%;">if</span>(<span style="color: #ffd700;">$env:ERLANG_ROOT</span>)
  {
    <span style="color: #0087ff; font-size: 105%; font-weight: bold;">invoke-expression</span> <span style="color: #ffaf87;">"$env:ERLANG_ROOT\bin\erlc.exe $script.erl"</span>
    <span style="color: #ffafaf; font-size: 105%;">if</span>(<span style="color: #ffd700;">$lastexitcode</span> <span style="color: #cdcd00; font-size: 105%;">-eq</span> <span style="color: #ffaf87;">"0"</span>)
    {
      <span style="color: #0087ff; font-size: 105%; font-weight: bold;">invoke-expression</span> <span style="color: #ffaf87;">"$env:ERLANG_ROOT\bin\erl.exe -noshell -s $script main $args"</span>
    }
  }
}
</pre>




<p>
The function take an Erlang module name runs it using the runtime in the <code>-noshell</code> mode. It assumes
that module exports a <code>main/1</code> function that serves as the entry point. The program I wrote earlier
does not, so we'd need a driver module. <a href="https://github.com/aldrin/ajd/blob/master/code/misc/sieve.erl">Here</a> is one:
</p>



<pre class="src src-erlang">% shell driver for sieve.hrl
-module(sieve).
-export([main/1]).
-include(<span style="color: #ffaf87;">"sieve.hrl"</span>).

main([A])-&gt;
    Print = fun(X) -&gt; io:format(<span style="color: #ffaf87;">"~p "</span>,[X]) end,
    Primes = primes(list_to_integer(atom_to_list(A))),
    lists:foreach(Print, Primes),
    io:format(<span style="color: #ffaf87;">"~n"</span>),
    init:stop().
</pre>




<p>
Now those 4 lines can be run in Powershell instead of the Erlang shell:
</p>



<pre class="example">C:\ajd\code\misc &gt; erlang sieve 100
2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97
</pre>



<p>
That then should open up Erlang for various interesting possibilities. <a href="http://wonderingminstrels.blogspot.com/2002/05/happiness-a-milne.html">And that, said John, is that</a>.
</p></div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 29 May 2011</p>
<p class="author">Author: aldrin j d'souza</p>
<p class="creator">Org version 7.7 with Emacs version 23</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
