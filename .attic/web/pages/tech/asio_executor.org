#+DATE: 07 September 2011

Thread-Pool Executor using Boost.ASIO

Consider the problem of writing a thread pool executor: i.e. an abstraction that takes arbitrary
user defined tasks and executes them concurrently over a pool of threads. Here's a (slightly
overweight) [[http://download.oracle.com/javase/6/docs/api/java/util/concurrent/ThreadPoolExecutor.html][example]] of the abstraction from =java.util.concurrent=. In this note, I describe another
(lean) implementation using a few bits from the treasure trove of [[http://www.boost.org/doc/libs/1_47_0/doc/html/boost_asio.html][Boost.ASIO]].

[[https://github.com/aldrin/ajd/blob/master/code/ajd/explore/test/src/executor_test.cc][Here's]] what I expect from the executor (syntactically):

#+INCLUDE "../../../code/ajd/explore/test/src/executor_test.cc" src c++

I expect to create an executor with the specified number of threads in its pool and to have it ready
to jobs that I submit during the lifetime of the instance. The destructor must wait till the last
submitted job is completed and then clean up everything. As far as the tasks go, anything that is
invokable must be acceptable.

With those requirements in mind, [[https://github.com/aldrin/ajd/blob/master/code/ajd/explore/main/include/executor.h][here]]'s an complete implementation:

#+INCLUDE "../../../code/ajd/explore/main/include/executor.h" src c++

As someone who has written shabbily stitched executors in the past, I can't help but marvel at the
economy of this implementation. No dispatch queues, no mutexes to guard share state, no condition
variables to signal job arrivals, no shutdown flags, no nothing. Just the neat, power-packed
=asio::io_service= facade and we're done. Of course, there's still quite a bit left before we use
this in a complete application, but how cool is that for a start?
