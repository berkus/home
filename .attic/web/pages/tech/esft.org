#+DATE: 13 August 2011
#+OPTIONS: ^:nil

Why =enable_shared_from_this=?

The [[http://www.boost.org/doc/libs/][boost]] libraries are simple to use but the neatness of their abstractions hides a lot of wizardry
that lies beneath. To use them effectively, you don't usually need to look beneath their covers,
but, a little insight, as the [[http://www.tsa.gov/][TSA]] will have you believe, goes a long way in understanding the
intentions. This note is about one such neat abstraction: [[http://www.boost.org/doc/libs/1_47_0/libs/smart_ptr/enable_shared_from_this.html][enable_shared_from_this]].

Allow me to start with a brief refresher of smart pointers (in boost, TR1 and C++11.)

Consider the following tests (also [[https://github.com/aldrin/ajd/blob/master/code/ajd/explore/test/src/shared_ptr_test.cc][here]]):

#+BEGIN_SRC c++
TEST(SmartPtrs, BasicUsage)
{
    shared_ptr<int> p(new int);
    {
        shared_ptr<int> q(p);
        ASSERT_FALSE(p.unique() || q.unique());
        ASSERT_EQ(2, q.use_count());
    }
    ASSERT_TRUE(p.unique());
}

TEST(SmartPtrsDeathTest, BadUsageDoubleDelete)
{
    ASSERT_DEATH(
    {
        int *i = new int;
        shared_ptr<int> p(i);
        {
            shared_ptr<int> q(i);
        }
    }, ".*");
}
#+END_SRC

The first shows the expected usage of =shared_ptr= and second serves as a warning against wrapping
the same raw pointer into more than one =shared_ptr=. Both =p= and =q= consider themselves as the
unique owners of the wrapped pointer. Consequently, they both deallocate it while going out of
scope, causing a double free and a crash. This is because a =shared_ptr= is not /intrusive/ i.e. the
reference count is not stored in the pointer being wrapped, instead, it is stored in the
=shared_ptr= instance. It is thus, the user's responsibility, to ensure that multiple ownership
situations are prevented. Now consider this:

#+BEGIN_SRC c++
TEST(SmartPtrs, WeakPtrUsage)
{
    shared_ptr<int> p(new int);
    weak_ptr<int> w(p);
    {
        ASSERT_EQ(1, p.use_count());
        shared_ptr<int> q = w.lock();
        ASSERT_EQ(2, q.use_count());
    }
    ASSERT_EQ(1, w.use_count());
    p.reset();
    ASSERT_TRUE(w.expired());
}
#+END_SRC

This test confirms the role of a =weak_ptr= as a side-kick of another =shared_ptr= instance. A
=weak_ptr= does not claim ownership to the underlying pointer, it is just a rain-check we keep to
claim ownership in the future, if we need to. You can't access the underlying pointer directly from
a =weak_ptr=, you need to =lock= it first, and in doing so create a =shared_ptr= that shares
ownership with the original =share_ptr=. All this is very nice and dandy, but the real reason why
=weak_ptr= exists in the standard library is because it is critical in breaking cyclic
references. And that brings us to the point of this note.

* The Problem
Consider the task of writing two classes: =Student= and =Course=, as shown below:

#+BEGIN_SRC c++
  class Student;
  
  class Course
  {
  public:
      void enroll(shared_ptr<Student> s)
      {
          register_.push_back(s);
      }
  private:
      vector<shared_ptr<Student>> register_;
  };
  
  class Student
  {
  public:
      void offer(Course &c)
      {
          if (interested_in(c))
          {
              c.enroll(/*this*/);
          }
      }
  private:
      bool interested_in(Course &c)
      {
          return true;
      }
  };
  
#+END_SRC

A =Course= holds a collection of =Student= instances that =enroll= into it. The =offer= method in
=Student= abstracts the act of offering a course to a given student. Depending on the interests
(abstracted by =interested_in=) the =Student::offer= implementation is expected to invoke
=Course::enroll= with the equivalent of =this=. And there's our problem: how do we store a
=shared_ptr= to =this= inside an instance? (Here's a [[http://www.boost.org/doc/libs/1_47_0/doc/html/boost_asio/example/http/server/connection.cpp][/real/]] class that has a similar need)

Consider solving the problem iteratively in the sequence of tests below (also [[https://github.com/aldrin/ajd/blob/master/code/ajd/explore/test/src/esft_test.cc][here]]). Here's a first
cut of =Student::offer=

#+BEGIN_SRC c++
  void Student::offer(Course &c)
  {
      if (interested_in(c))
      {
          c.enroll(shared_ptr<Student>(this));
      }
  }
  
  TEST(StudentCourse, BadUsageDoubleDelete)
  {
      ASSERT_DEATH(
      {
          Course math;
          shared_ptr<Student> s(new Student);
          s->offer(math);
      }, ".*");
  }
  
#+END_SRC

This is not a lot different from the other =BadUsageDoubleDelete= test we wrote earlier. It suffers
from the same problem (multiple =shared_ptr= pointing to the same memory) and meets the same end
(crash with a double delete.) Here's another attempt:

#+BEGIN_SRC c++
  class Student
  {
  public:
      void offer(Course &c)
      {
          if (interested_in(c))
          {
              c.enroll(self_);
          }
      }
      void set_this(shared_ptr<Student> self)
      {
          self_ = self;
      }
  private:
      shared_ptr<Student> self_;
      bool interested_in(Course &c)
      {
          return true;
      }
  };
  TEST(StudentCourse, BadUsageLeaks)
  {
      Course math;
      shared_ptr<Student> s(new Student);
      s->set_this(s);
      s->offer(math);
      ASSERT_EQ(3, s.use_count());
  }
  
#+END_SRC

This may not crash but it isn't any better. To ensure we use the same reference count, we extend
=Student= to include a =shared_ptr= to itself. We add a =set_this= method to record the original
=shared_ptr= back into the instance. This gets us around the double delete, but by means of a cyclic
reference, pushes us to the other extreme (no delete). The member =self_= adds to the reference
count which can't be decremented automatically. We can, of course, add a =reset_this= method to do
that, but doing so defeats the whole purpose. As the test asserts, the =use_count= is 3, and we have
only two objects (=s= and =math=) to bring it down. Leak happens. 

Let's try again.

#+BEGIN_SRC c++
  class Student
  {
      // same as before
      void offer(Course &c)
      {
          if (interested_in(c))
          {
              c.enroll(self_.lock());
          }
      }
  private:
      weak_ptr<Student> self_;
      // same as before
  };
  
  TEST(StudentCourse, Works)
  {
      Course math;
      shared_ptr<Student> s(new Student);
      s->set_this(s);
      s->offer(math);
      ASSERT_EQ(2, s.use_count());
  }
  
#+END_SRC

There's our =weak_ptr= to the rescue. All that has changed from the second attempt is the type of
the =self_= member and we now use its =lock= method to construct a strong reference only where
required. This ensures that we do not block a reference in the instance and don't leak. As I wrote
earlier, this breaking of cyclic references is the very reason why we use =weak_ptr=.

* The Solution
Let's step back and consider the changes we made to realize our use case. We had to:

- Add a member =self_= to store a weak reference to =this=
- Add a new member =set_this= to record the original =shared_ptr= in =self_=
- Remember to call =set_this= after creating every =Student= instance.

That may sound like too much work and more importantly it also pollutes the =Student= interface
(especially the last item). Fortunately, there is a better way to do all this, and it is called
(surprise!)  =enable_shared_from_this=. Consider the following:

#+BEGIN_SRC c++
  class Student : public enable_shared_from_this<Student>
  {
  public:
      void offer(Course &c)
      {
          if (interested_in(c))
          {
              c.enroll(shared_from_this());
          }
      }
  private:
      bool interested_in(Course &c)
      {
          return true;
      }
  };
  TEST(StudentCourse, Best)
  {
      Course math;
      shared_ptr<Student> s(new Student);
      s->offer(math);
      ASSERT_EQ(2, s.use_count());
  }
  
#+END_SRC

The class =enable_shared_from_this= is buddies with =shared_ptr= and their friendship internally
enables all the machinery we listed above. In other words, when =share_ptr= notices the pointer it
is taking belongs to a class that derives from =enable_shared_from_this= it populates the weak
reference held as a protected member of =enable_shared_from_this=. The application subclass
(i.e. =Student=) can en-cash this weak reference anytime using the =shared_from_this= protected
member function. In summary, we get all we need, just by extending from =enable_shared_from_this=.

And, that, gentle reader, is why we need =enable_shared_from_this=.
